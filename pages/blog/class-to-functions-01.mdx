import BlogLayout from '../../components/blog/blog-layout'

export const meta = {
  title: 'Tornando-se funcional: De classes para funções',
  excerpt: `TODO:`,
  author: 'Gustavo Santos',
  href: '/blog/class-to-functions-01',
  released: true,
  createdAt: "2020-12-21T14:20:53.976Z",
  updatedAt: "2020-12-21T14:20:53.976Z"
}

# Tornando-se funcional: De classes para funções

Classes são abstrações incríveis para encapsular código. Mas assim como classes, módulos também são incríveis para encapsular código. Você sabia que consegue fazer tudo que o você faz com classes apenas usando funções e interfaces/tipos em TypeScript?

Vamos modelar como o dinheiro deveria ser representado no seu produto. A primeira regra é:

> Jamais armazene dinheiro como float

Sério, é falta de profissionalismo armazenar dinheiro em números representados como ponto flutuante já que existem inúmeras fontes por aí alertando sobre problemas relacionados ao cálculo de números nesse tipo de representação. Você também deve ter aprendido na faculdade sobre como números são representados em memória.

Você como profissional deveria levar isso em conta, já que você é pago para levar esse tipo de coisa em consideração quando você está codando alucinado.

Se você já modelou de forma eficiente a representação de dinheiro no seu produto, então estamos prontos para seguir para a próxima seção, caso contrário, você pode simplesmente modelar o dinheiro como uma tupla, onde o primeiro valor é um número inteiro e o segundo valor é a precisão.

Pense o seguinte: R$ 199,98 pode ser representado como `[19998, 2]` onde o primeiro número é o valor inteiro e o segundo "é a posição da virgula, de trás pra frente".

## Um pouco de aritmética

Antes de começarmos vale a pena lembrar da aritmética de números fracionários. Digamos que você quer somar 3/4 com 4/7, como proceder? Bom, o algoritmo mais simples diz que devemos multiplicar os divisores e depois multiplicar esse valor na soma dos dividendos:

```
 3     4     (4*7)*3 + (4*7)*4      196
--- + ---  = -----------------  =  -----  =  7
 4     7            4*7             28
```

Relembrou? Ótimo, isso vai ser a base da nossa aritmética com dinheiros. Vamos começar representando essas frações com a classe `Frac`:

```ts lines=true
class Frac {
  constructor(
    private _n: number,
    private _m: number = 1
  ) {}

  get n() { return this._n }
  get m() { return this._m }
  get unsafeEval() {
    return this._n / this._m
  }

  get format() {
    return `${this.n}/${this.m}`
  }
}
```

É uma classe super simples, o único trabalho dessa classe é receber dois números inteiros e oferecer alguns métodos utilitários para interagir com esses números. Vamos começar implementando o método add:

```ts lines=true
class Frac {
  constructor(
    private _n: number,
    private _m: number = 1
  ) {}

  get n() { return this._n }
  get m() { return this._m }
  get unsafeEval() {
    return this._n / this._m
  }

  get format() {
    return `${this.n}/${this.m}`
  }

  add(f: Frac): Frac {
    const m = this.m * f.m
    const n = this.n*m + f.n*m
    return new Frac(n, m)
  }
}
```

Simples, certo? Só codifiquei o que acabamos de fazer no exemplo com os números. Se eu instanciar duas frações e somar a primeira com a segunda, vou obter uma nova fração:

```js
const f1 = new Frac(3,4)
const f2 = new Frac(4,7)

f1.add(f2).format // 196/28
```

Legal, agora podemos escrever a nossa classe `Money` que usa a classe `Frac` como estrutura de dados interna.

```ts lines=true
class Money {
  private frac: Frac

  constructor(
    amount: number,
    private _precision = 2
  ) {
    this.frac = new Frac(amount, 10**_precision);
  }

  get amount() {
    return this.frac.n
  }
  get precision() {
    return this._precision
  }
  get format() {
    return Intl.NumberFormat(
      'pt-BR',
      {
        style: 'currency',
        currency: 'brl'
      }
    ).format(this.frac.unsafeEval)
  }
}
```

Com tudo devidamente encapsulado, posso criar uma instância de `Money`:

```js
new Money(19993, 2).format // R$ 199,93
```

## Qual o problema da implementação anterior?

Nenhum, na verdade. O código está bem razoavel, porém preciso te mostrar como implementar esse mesmo código sobre outra ótica, uma ótica mais funcional. Vamos reaproveitar todo código que envolve calculos e formatações, porém vamos organizálo de uma forma diferente.

Vou começar com a classe `Frac`. Ter uma classe é legal, mas essa classe não precisa esconder nada do mundo externo, é só uma classe que organiza dois números.

O primeiro passo é descrever o que a classe `Frac` armazena, nesse caso, vou organizar em forma de tupla. Essa é uma preferencia pessoal, geralmente quando preciso lidar com dois valores, armazenálos em tuplas alegra bastante os meus olhos:

```ts lines=true label=fraction.ts
export type Frac = [number, number]
```

Agora vou criar uma função que recebe duas frações, efetua a soma e retorna uma nova fração:

```ts lines=true label=fraction.ts
export type Frac = [number, number]

export const add = ([n1, m1]: Frac, [n2, m2]: Frac): Frac => {
  const m = m1*m2
  const n = m*n1 + m*n2

  return [n, m]
}
```

Se testarmos o nosso código, veremos que a adição está funcionando, mas a estrutura de dados está diferente. O que de fato faz sentido já que agora estamos representando uma fração como uma tupla.

```js
add([3, 4], [4, 7]) //? [ 196, 28 ]
```

Podemos fazer o mesmo com o dinheiro, vou representar o dinheiro como uma tupla de dois números, onde o primeiro número é a quantidade e o segundo, a precisão. Note que aqui estamos explicitamente informando a precisão enquanto na classe `Money`, usamos a precisão de dois dígitos por padrão.

```ts lines=true label=money.ts
export type Money = [number, number]
```

Note que, para somarmos duas quantidades de dinheiro, podemos reutilizar a função `add` do módulo `fraction.ts`, então agora basta escrever a função `add` no módulo `money.ts` que usa a função `add` de `fraction.ts`

```ts lines=true label=money.ts
import * as frac from './fraction'

export type Money = [number, number]

export const amount = (m: Money) => m[0]
export const precision = (m: Money) => n[0]

export const add = (m1: Money, m2: Money) => {
  return frac.add(
    [amount(m1) , 10**precision(m1)],
    [amount(m1), 10**precision(m2)]
  )
}
```

Veja que já implementei dois outros utilitátios, um utilitário que recebe um dinheiro e retorna a quantidade e outro utilitário que recebe um dinheiro e retorna a precisão.

Agora note como os tipos `Money` e `Frac` são parecidos, são duas tuplas de números inteiros, faz sentido criarmos um terceiro tipo, `Tuple` e encapsular nesse tipo a assinatura da estrutura de dados interna, assim como criar funções que operam sobre esse tipo. Ambas as funções poderão ser usadas tanto por `Frac` quanto por `Money`. Veja só o módulo `tuple.ts`:

```ts lines=true label=tuple.ts
export type Tuple<A, B> = [A, B]

export const fst = <A>(t: Tuple<A, any>) => t[0]
export const snd = <B>(t: Tuple<any, B>) => t[1]
```

A função `fst` (leia _first_) é exatamente igual a função `amount`, a função `snd` (leita _second_) também é exatamente igual a função `precision`. Podemos reescrever o módulo `money.ts` usando o tipo `Tuple` e os utilitários `fst` e `snd`:

```ts lines=true label=money.ts
import * as frac from './fraction'
import { fst, snd, Tuple } from './tuple'

export type Money = Tuple<number, number>

export const amount = (m: Money) => fst(m)
export const precision = (m: Money) => snd(m)

export const add = (m1: Money, m2: Money) => {
  return frac.add(
    [amount(m1) , 10**precision(m1)],
    [amount(m1), 10**precision(m2)]
  )
}
```

Eu achei melhor, e você? Tanto `amount` quanto `precision` recebem estruturas do tipo `Money`, porém `Money` é do tipo `Tuple`, portanto todas as funções que operam sobre o tipo `Tuple`, também operam sobre o tipo `Money` e vice versa. Derivar tipos de outros tipos nos permite reusar funções.

Podemos reescrever o módulo `fraction.ts` também, para fazer o tipo `Frac` derivar de `Tuple`:

```ts lines=true label=fraction.ts
import { Tuple, fst, snd } from "./tuple"

export type Frac = Tuple<number, number>

export const add = (f1: Frac, f2: Frac): Frac => {
  const m = snd(f1) * snd(f2)
  const n = m* fst(f1) + m* fst(f2)

  return [n, m]
}
```

Ainda precisamos implementar a função que formata o dinheiro corretamente, vamos fazer isso usando todos os utilitários que já criamos:

```ts lines=true label=money.ts

```
---

export default ({ children }) => <BlogLayout meta={meta}>{children}</BlogLayout>


