import BlogLayout from '../../components/blog/blog-layout'
import { OuterLink } from '../../components/outer-link.js'
import { SnippetCard } from '../../components/snippets/snippet-card.js'

export const meta = {
  title: 'pipeline',
  excerpt: 'Compose functions by applying the result of the previous function to the next.',
  tags: ['javascript', 'snippet']
}

# Pipeline

When you need to compose two or more functions where the result of the first function application is the argument for the second function and so on, then the `pipeline` function could be useful.

## Code

```js label=pipeline.js
const pipeline = (...fns) =>
  (...args) =>
    fns.reduce((acc, fn) => fn(acc), args)
```

Pipeline is just a function that receives a list of functions then return a function that takes the initial argument (or arguments) and call all the functions in order.

## Example

```js
const f = (x) => `f(${x})`
const g = (x) => `g(${x})`
const h = (x) => `h(${x})`

const w = pipeline(f, g, h)
w(10, 11) //=> h(g(f(10,11)))
```

You can find this kind of function in various JavaScript libraries, such as <OuterLink href="https://github.com/lodash/lodash/wiki/FP-Guide">Lodash FP</OuterLink> or <OuterLink href="https://ramdajs.com/docs/#pipe">Ramda</OuterLink>

## See also

<SnippetCard snippet={{
  meta: {
    title: 'pipethrough',
    excerpt: 'Pipe data through a set of functions like Clojure -> or Elixir |> operators.',
    tags: ['javascript', 'snippet']
  },
  href: '/knowledge/javascript-pipethrough'
}} />

---

export default ({ children }) => <BlogLayout meta={meta}>{children}</BlogLayout>
