import BlogLayout from '../../../components/blog/blog-layout';
import { SnippetMetadata } from '../../../lib/snippet-metadata'
import { SignUpForm } from "../../../components/demo/signup-form";

export const meta = SnippetMetadata({
  title: 'Testing forms backed with React Hook Form',
  excerpt: 'React Hook Form is an amazing library but sometimes we get caught in some pitfalls while testing forms with asynchronous operations such as validation. In this article you will learn how to test forms with asynchronous validation.',
  tags: ['en', 'react', 'jest', 'testing-library', 'tutorial', 'english', 'javascript']
})


# Testing forms backed with React Hook Form

If you never hear about this library, stop reading this article right now and go to the [React Hook Form page](https://react-hook-form.com/).

I cannot express all my happiness with this library, is simpler than Formik, is fast and accept multiple validation engines. But often times I see programmers cracking their heads while testing forms backed by React Hook Form, in this tutorial you will see how to test forms with validation and I hope that your tests become much simpler.

## The form

Look at the following form that we will work with (go ahead and play with it):

<SignUpForm onSubmit={console.log} />

It's a simple sign up form at first, you need to input how you like to be called by, email, password and type again the password. Also, the form will validate your email and password. The email must be a valid email, and the password should be at least have length of 8 characters

If some field is invalid, a message of error indicating why the field is invalid will be shown right below the field (I hate when the validation error is far away from the field that is wrong).

## Set up the test

Before write any code, let's use the hat that allow us to add tests and think about how our application should work. Don't think in thinks like how to implement the form, how to style it, how to validate the inputs, how handle the form submission. None of that. Instead, think about what you want to deliver.

What is your objective? What the future code should deliver in terms of behaviour? Let's encode some of those rules in the test file!

```jsx label=__tests__/signup-form.test.js
import { SignUpForm } from '../signup-form'

describe(SignUpForm.name, () => {
  test.todo('should display required error when submit without fill the name field')
  test.todo('should display invalid error when submit with name field filled with spaces')
  test.todo('should display required error when submit without fill the email field')
  test.todo('should display required error when submit without fill the password field')
  test.todo('should display validation error when the email is invalid')
  test.todo('should display validation error when password confirmation does not match the password field')
  test.todo('should submit the form data when filled correctly')
})
```

The above list of tests *to do* isn't the full list of things that we can test about our form. It's a fair quantity of things that we need to think before start coding the form. Note that this isn't an article about TDD, it's an article about how to test forms that are backed by React Hook Form.

At the start we already know that we need a file named `signup-form.(js|jsx|tsx)` stored in the upper directory and this file should export the React component SignUpForm. I like to attribute the component name to the `describe` test when unit testing a single React component.

Let's write the first test.

```jsx label=__tests__/signup-form.test.js
import { SignUpForm } from '../signup-form'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'

describe(SignUpForm.name, () => {
  test('should display required error when submit without fill the name field', () => {
    const onSubmit = jest.fn()
    render(<SignUpForm onSubmit={onSubmit} />)

    const submitButton = screen.getByText('Sign Up')
    userEvent.click(submitButton)

    expect(
      screen.getByText(
        'You need to type your name or how you like to be called.'
      )
    ).toBeInTheDocument()
  })

  //..
})
```

Running the test file above we will get a bunch of erros because our form isn't implemented yet. Now I will take off my thinker hat and put my refactoring hat and let's implement the basics to this form work without any validation. With the power of fast-forward to the future, I will present in the next section the form code with the styles already done (the same that you play before).

## The form code

I will not walk through the whole code but there are some decisions that I need to comment. The first decision is use Yup for validation; you can implement the same validations using the native validation engine that React Hook Form provide,
but the objective here is cover maximum features with less effort, and the ability to use external validation engines is a big feature of React Hook Form. That's the reason to choose Yup as validation engine.

The second decision is to avoid premature optimization and extract each input to the isolated component. It's fine here to mount the form as you can see below.

```jsx label=signup-form.js
import { useForm } from 'react-hook-form'

export function SignUpForm({ onSubmit }) {
  const { handleSubmit, register } = useForm()

  const onValid = ({ name, email, password }) =>
    onSubmit({ name, email, password })

  const onInvalid = () => {}

  return (
    <form
      className="flex flex-col justify-start items-start w-full rounded-md border border-gray-200 mt-2 mb-2 p-6"
      onSubmit={handleSubmit(onValid, onInvalid)}
    >
      <h1 className="font-bold text-2xl mb-6 text-coolGray-900">Welcome</h1>

      <label htmlFor="form-name" className="flex flex-col w-full mb-2">
        <span className="font-bold text-coolGray-600">
          How you like to be called?
        </span>
        <input
          id="form-name"
          name="name"
          placeholder="Ex: George, Mr W, Mary Jane"
          defaultValue=""
          ref={register}
          className="w-full text-coolGray-800 pt-2 pb-2 pr-4 pl-4 border-b-2 border-gray-300 focus:border-gray-500"
        />
      </label>

      <label htmlFor="form-email" className="flex flex-col w-full mb-2">
        <span className="font-bold text-coolGray-600">Your e-mail</span>
        <input
          id="form-email"
          name="email"
          type="email"
          placeholder="Ex: spiderman@marvel.co"
          defaultValue=""
          ref={register}
          className="w-full text-coolGray-800 pt-2 pb-2 pr-4 pl-4 border-b-2 border-gray-300 focus:border-gray-500"
        />
      </label>

      <label htmlFor="form-password" className="flex flex-col w-full mb-2">
        <span className="font-bold text-coolGray-600">Your password</span>
        <input
          id="form-password"
          name="password"
          type="password"
          placeholder="Ex: this is a HUGE 123 password"
          defaultValue=""
          ref={register}
          className="w-full text-coolGray-800 pt-2 pb-2 pr-4 pl-4 border-b-2 border-gray-300 focus:border-gray-500"
        />
      </label>

      <label
        htmlFor="form-password-confirmation"
        className="flex flex-col w-full mb-2"
      >
        <span className="font-bold text-coolGray-600">
          Type again your password
        </span>
        <input
          id="form-password-confirmation"
          name="passwordConfirmation"
          type="password"
          placeholder="The same that you already typed before"
          defaultValue=""
          ref={register}
          className="w-full text-coolGray-800 pt-2 pb-2 pr-4 pl-4 border-b-2 border-gray-300 focus:border-gray-500"
        />
      </label>

      <div className="flex justify-center items-center mt-6">
        <button
          type="submit"
          className="pt-2 pb-2 pr-6 pl-6 bg-pink-600 text-pink-50 border border-pink-700 shadow-lg font-bold rounded-md"
        >
          Sign Up
        </button>
      </div>
    </form>
  )
}
```

It's a bunch of code, but it's easy to understand what's going on. We have the form title, all the fields stacked, and the submission button.

To be able to use third party validations with RHF we need to implement our own validation resolver. I will use Yup as validation engine, and the own RHF Yup resolver. The resolver is only a pattern (or, if helps, an "interface") that allow the RFH to talk with the validation engine.

```jsx label=signup-form.js
// ..
import { yupResolver } from '@hookform/resolvers/yup'
import * as yup from 'yup'

const schema = yup.object().shape({
  name: yup.string().required()
})

export function SignUpForm({ onSubmit }) {
  const { handleSubmit, register, errors } = useForm({
    resolver: yupResolver(schema)
  })

  // ..

  return (
    <form
      className="flex flex-col justify-start items-start w-full rounded-md border border-gray-200 mt-2 mb-2 p-6"
      onSubmit={handleSubmit(onValid, onInvalid)}
    >
      <h1 className="font-bold text-2xl mb-6 text-coolGray-900">Welcome</h1>

      <label htmlFor="form-name" className="flex flex-col w-full mb-2">
        <span className="font-bold text-coolGray-600">
          How you like to be called?
        </span>
        <input
          id="form-name"
          name="name"
          placeholder="Ex: George, Mr W, Mary Jane"
          defaultValue=""
          ref={register}
          className="w-full text-coolGray-800 pt-2 pb-2 pr-4 pl-4 border-b-2 border-gray-300 focus:border-gray-500"
        />
        <span className="text-red-600">{errors.name?.message}</span>
      </label>


    </form>
  )
}
```

If you run the tests and debug the output, we can see that there is a custom message being rendered, but isn't the message that we want:

```html
<label
  class="flex flex-col w-full mb-2"
  for="form-name"
>
  <span
    class="font-bold text-coolGray-600"
  >
    How you like to be called?
  </span>
  <input
    class="w-full text-coolGray-800 pt-2 pb-2 pr-4 pl-4 border-b-2 border-gray-300 focus:border-gray-500"
    id="form-name"
    name="name"
    placeholder="Ex: George, Mr W, Mary Jane"
    value=""
  />
  <span class="text-red-600">
    name is a required field
  </span>
</label>
```

I'll change the validation definition and include the custom validation message:

```js label=signup-form.js
const schema = yup.object().shape({
  name: yup
    .string()
    .required('You need to type your name or how you like to be called.')
})
```

## How it works?

You might be thinking how the custom validator message that we configure in your validation schema is rendered to the screen.

Remember that we use custom resolvers to "teach" the RHF how to talk with the validation engine? In our case, the resolver `yupResolver` is the responsible to pass the form data to Yup, **wait** for the validation to end. Then the resolver collect the errors and pass them back to the RHF which deliver to us via `errors` property returned from `useForm` hook call.

There is many validation engines out there, and most of them are asynchronous, which means that we need to *wait* until the validation ends. It's impossible to turn an asynchronous behaviour into synchronous (at least without use generators), so the RHF must validate the form data asynchronously.

Why this is important? It's important because it impacts directly into our tests. When we test asynchronous code, we need to *wait* until some set of operations end. Form validation is an asynchronous operation, so we need to *wait* every time that we need to make some assertion about something that has asynchronous behaviour.

## Refactoring our test

Let's change our test and turn it asynchronous:

```jsx label=__tests__/signup-form.test.js
//..

test('should display required error when submit without fill the name field', async () => {
  const onSubmit = jest.fn()
  render(<SignUpForm onSubmit={onSubmit} />)

  const submitButton = screen.getByText('Sign Up')
  userEvent.click(submitButton)

  await waitFor(() =>
    expect(
      screen.getByText(
        'You need to type your name or how you like to be called.'
      )
    ).toBeInTheDocument()
  )
})

//..
```

Running our tests we are back to green ("back to green" means "we were in a state where the tests fail, we refactor the code and make the tests pass again").

Let's change our hat again and implement all other tests:

```jsx label=__tests__/signup-form.test.js
import { SignUpForm } from '../signup-form'
import { render, screen, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'

describe(SignUpForm.name, () => {
  test('should display required error when submit without fill the name field', async () => {
    const onSubmit = jest.fn()
    render(<SignUpForm onSubmit={onSubmit} />)

    const submitButton = screen.getByText('Sign Up')
    userEvent.click(submitButton)

    await waitFor(() =>
      expect(
        screen.getByText(
          'You need to type your name or how you like to be called'
        )
      ).toBeInTheDocument()
    )
  })

  test('should display invalid error when submit with name field filled with spaces', async () => {
    const onSubmit = jest.fn()
    render(<SignUpForm onSubmit={onSubmit} />)

    const nameInput = screen.getByLabelText('How you like to be called?')
    await userEvent.type(nameInput, '    ')

    const submitButton = screen.getByText('Sign Up')
    userEvent.click(submitButton)

    await waitFor(() =>
      expect(
        screen.getByText(
          'You need to type your name or how you like to be called'
        )
      ).toBeInTheDocument()
    )
  })

  test('should display required error when submit without fill the email field', async () => {
    const onSubmit = jest.fn()
    render(<SignUpForm onSubmit={onSubmit} />)

    const submitButton = screen.getByText('Sign Up')
    userEvent.click(submitButton)

    await waitFor(() =>
      expect(
        screen.getByText('You need to type a valid e-mail that you have access')
      ).toBeInTheDocument()
    )
  })

  test('should display required error when submit without fill the password field', async () => {
    const onSubmit = jest.fn()
    render(<SignUpForm onSubmit={onSubmit} />)

    const submitButton = screen.getByText('Sign Up')
    userEvent.click(submitButton)

    await waitFor(() =>
      expect(
        screen.getByText('Your password is too short (min 8)')
      ).toBeInTheDocument()
    )
  })

  test('should display validation error when the email is invalid', async () => {
    const onSubmit = jest.fn()
    render(<SignUpForm onSubmit={onSubmit} />)

    const emailInput = screen.getByLabelText('Your e-mail')
    await userEvent.type(emailInput, 'invalid_email')

    const submitButton = screen.getByText('Sign Up')
    userEvent.click(submitButton)

    await waitFor(() =>
      expect(screen.getByText('You typed a invalid email')).toBeInTheDocument()
    )
  })

  test('should display validation error when password confirmation does not match the password field', async () => {
    const onSubmit = jest.fn()
    render(<SignUpForm onSubmit={onSubmit} />)

    const passwordInput = screen.getByLabelText('Your password')
    await userEvent.type(passwordInput, '123456789')

    const passwordConfirmationInput = screen.getByLabelText(
      'Type again your password'
    )
    await userEvent.type(passwordConfirmationInput, '99999999')

    const submitButton = screen.getByText('Sign Up')
    userEvent.click(submitButton)

    await waitFor(() =>
      expect(
        screen.getByText('Your password do not match the password confirmation')
      ).toBeInTheDocument()
    )
  })

  test('should submit the form data when filled correctly', async () => {
    const formData = {
      name: 'User name',
      email: 'user@email.com',
      password: 'user_password'
    }
    const onSubmit = jest.fn()
    render(<SignUpForm onSubmit={onSubmit} />)

    const nameInput = screen.getByLabelText('How you like to be called?')
    await userEvent.type(nameInput, formData.name)

    const emailInput = screen.getByLabelText('Your e-mail')
    await userEvent.type(emailInput, formData.email)

    const passwordInput = screen.getByLabelText('Your password')
    await userEvent.type(passwordInput, formData.password)

    const passwordConfirmationInput = screen.getByLabelText(
      'Type again your password'
    )
    await userEvent.type(passwordConfirmationInput, formData.password)

    const submitButton = screen.getByText('Sign Up')
    userEvent.click(submitButton)

    await waitFor(() => expect(onSubmit).toBeCalledWith(formData))
  })
})
```

## Refactoring our code

Running our tests again we will them failing, let's first adjust our validation schema to validate all other fields:

```jsx label=signup-form.js
//..

const schema = yup.object().shape({
  name: yup
    .string()
    .trim()
    .required('You need to type your name or how you like to be called'),
  email: yup
    .string()
    .email('You typed a invalid email')
    .required('You need to type a valid e-mail that you have access'),
  password: yup
    .string()
    .min(8, 'Your password is too short (min 8)')
    .required('You must type a password'),
  passwordConfirmation: yup
    .string()
    .oneOf(
      [yup.ref('password')],
      'Your password do not match the password confirmation'
    )
})

//..
```

Now I will refactor the remaining input fields to display the error messages:

```jsx label=signup-form.js
import { useForm } from 'react-hook-form'
import { yupResolver } from '@hookform/resolvers/yup'
import * as yup from 'yup'

const schema = yup.object().shape({
  name: yup
    .string()
    .trim()
    .required('You need to type your name or how you like to be called'),
  email: yup
    .string()
    .email('You typed a invalid email')
    .required('You need to type a valid e-mail that you have access'),
  password: yup
    .string()
    .min(8, 'Your password is too short (min 8)')
    .required('You must type a password'),
  passwordConfirmation: yup
    .string()
    .oneOf(
      [yup.ref('password')],
      'Your password do not match the password confirmation'
    )
})

export function SignUpForm({ onSubmit }) {
  const { handleSubmit, register, errors } = useForm({
    resolver: yupResolver(schema)
  })

  const onValid = ({ name, email, password }) =>
    onSubmit({ name, email, password })

  const onInvalid = () => {}

  return (
    <form
      className="flex flex-col justify-start items-start w-full rounded-md border border-gray-200 mt-2 mb-2 p-6"
      onSubmit={handleSubmit(onValid, onInvalid)}
    >
      <h1 className="font-bold text-2xl mb-6 text-coolGray-900">Welcome</h1>

      <label htmlFor="form-name" className="flex flex-col w-full mb-2">
        <span className="font-bold text-coolGray-600">
          How you like to be called?
        </span>
        <input
          id="form-name"
          name="name"
          placeholder="Ex: George, Mr W, Mary Jane"
          defaultValue=""
          ref={register}
          className="w-full text-coolGray-800 pt-2 pb-2 pr-4 pl-4 border-b-2 border-gray-300 focus:border-gray-500"
        />
        <span className="text-red-600">{errors.name?.message}</span>
      </label>

      <label htmlFor="form-email" className="flex flex-col w-full mb-2">
        <span className="font-bold text-coolGray-600">Your e-mail</span>
        <input
          id="form-email"
          name="email"
          type="email"
          placeholder="Ex: spiderman@marvel.co"
          defaultValue=""
          ref={register}
          className="w-full text-coolGray-800 pt-2 pb-2 pr-4 pl-4 border-b-2 border-gray-300 focus:border-gray-500"
        />
        <span className="text-red-600">{errors.email?.message}</span>
      </label>

      <label htmlFor="form-password" className="flex flex-col w-full mb-2">
        <span className="font-bold text-coolGray-600">Your password</span>
        <input
          id="form-password"
          name="password"
          type="password"
          placeholder="Ex: this is a HUGE 123 password"
          defaultValue=""
          ref={register}
          className="w-full text-coolGray-800 pt-2 pb-2 pr-4 pl-4 border-b-2 border-gray-300 focus:border-gray-500"
        />
        <span className="text-red-600">{errors.password?.message}</span>
      </label>

      <label
        htmlFor="form-password-confirmation"
        className="flex flex-col w-full mb-2"
      >
        <span className="font-bold text-coolGray-600">
          Type again your password
        </span>
        <input
          id="form-password-confirmation"
          name="passwordConfirmation"
          type="password"
          placeholder="The same that you already typed before"
          defaultValue=""
          ref={register}
          className="w-full text-coolGray-800 pt-2 pb-2 pr-4 pl-4 border-b-2 border-gray-300 focus:border-gray-500"
        />
        <span className="text-red-600">
          {errors.passwordConfirmation?.message}
        </span>
      </label>

      <div className="flex justify-center items-center mt-6">
        <button
          type="submit"
          className="pt-2 pb-2 pr-6 pl-6 bg-pink-600 text-pink-50 border border-pink-700 shadow-lg font-bold rounded-md"
        >
          Sign Up
        </button>
      </div>
    </form>
  )
}
```

Running our tests we are back to green.

## Conclusion

If you follow this guide until here, congratulations! If you don't understand the whole picture yet, here is a quick explanation: when using React Hook Form as form backend, and when I said "form backend" I mean "the machinery behind the form behaviour" and this includes validation we must await for the form operations do be done before done any assertion.

Validation is an asynchronous process and everytime that we test React components that has asynchronous behaviour, we need to wait to those operations to end before making any assertion about the test result.


export default ({ children }) => <BlogLayout meta={meta}>{children}</BlogLayout>